#! /usr/bin/env python

import math
import rospy
from sensor_msgs.msg import Image
from std_msgs.msg import Float32MultiArray
from cv_bridge import CvBridge
import cv2
import numpy

        # import readline # optional, will allow Up/Down/History in the console
        # import code
        # variables = globals().copy()
        # variables.update(locals())
        # shell = code.InteractiveConsole(variables)
        # shell.interact()

class LaserCamCalib(object):
    def __init__(self):
        self._bridge = CvBridge()
        self._camera_matrix = numpy.array([[617.436828613281, 0, 326.484985351562], [0, 617.313415527344, 235.550384521484], [0, 0, 1]])
        self._rows = 7
        self._cols = 10
        self._object_points = numpy.empty((self._rows * self._cols, 3))
        self._square_size = 0.05

        for i in range(self._rows * self._cols):
            x = 0
            y = int(i / self._rows) * self._square_size
            z = (i % self._rows) * self._square_size
            self._object_points[i] = numpy.array([x, y, z])

        rospy.Subscriber('/usb_cam/image_raw', Image, self.image_cb)
        rospy.Subscriber('/model_plane_coeffs', Float32MultiArray, self.coeffs_cb)
        #rospy.Subscriber('/calib_test/new_plane', 
        self._img_pub = rospy.Publisher('/calib_test/img', Image, queue_size=1)
        rospy.spin()

    def coeffs_cb(self, msg):
        rospy.loginfo(msg.data)

    def image_cb(self, msg):
        cv_image = self._bridge.imgmsg_to_cv2(msg, msg.encoding)
        mono = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
        #TODO don't hardcode board dims
        (ok, corners) = cv2.findChessboardCorners(mono, (self._rows, self._cols), 
            flags = cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE | cv2.CALIB_CB_FAST_CHECK)

        if ok:
            if corners[0, 0, 1] > corners[-1, 0, 1]:
                numpy.flipud(corners)

            # refine detected corners
            # Use a radius of half the minimum distance between corners. This should be large enough to snap to the
            # correct corner, but not so large as to include a wrong corner in the search window.
            dist = lambda p1, p2: math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
            min_distance = float("inf")
            for index in range(len(corners)):
                if (index + 1) % self._cols:
                    min_distance = min(min_distance, dist(corners[index, 0], corners[index + 1, 0]))
                if index + self._cols < len(corners):
                    min_distance = min(min_distance, dist(corners[index, 0], corners[index + self._cols, 0]))

            radius = int(math.ceil(min_distance * 0.5))
            cv2.cornerSubPix(mono, corners, (radius,radius), (-1,-1),
                                        ( cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.1 ))
            
            for index in range(len(corners)):
                cv2.circle(cv_image, (corners[index, 0, 0], corners[index, 0, 1]), 3, (0, 0, 255), 1)

            ret, r, t = cv2.solvePnP(self._object_points, corners, self._camera_matrix, (0, 0, 0, 0))
            axis = numpy.float32([[0, 0, 0], [0.15, 0, 0], [0, 0.15, 0], [0, 0, 0.15]])
            img_points, _ = cv2.projectPoints(axis, r, t, self._camera_matrix, (0, 0, 0, 0))

            cv2.line(cv_image, tuple(corners[0].ravel()), (img_points[1, 0, 0], img_points[1, 0, 1]), (255, 0, 0), 5)
            cv2.line(cv_image, tuple(corners[0].ravel()), (img_points[2, 0, 0], img_points[2, 0, 1]), (0, 255, 0), 5)
            cv2.line(cv_image, tuple(corners[0].ravel()), (img_points[3, 0, 0], img_points[3, 0, 1]), (0, 0, 255), 5)


        self._img_pub.publish(self._bridge.cv2_to_imgmsg(cv_image))

if __name__ == '__main__':
    rospy.init_node('calib_test', anonymous=True)
    LaserCamCalib()