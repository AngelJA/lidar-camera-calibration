#! /usr/bin/env python

import math
import rospy
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import numpy

        # import readline # optional, will allow Up/Down/History in the console
        # import code
        # variables = globals().copy()
        # variables.update(locals())
        # shell = code.InteractiveConsole(variables)
        # shell.interact()

class LaserCamCalib(object):
    def __init__(self):
        self._bridge = CvBridge()

        rospy.Subscriber('/usb_cam/image_raw', Image, self.image_cb)
        self._img_pub = rospy.Publisher('/calib_test/img', Image, queue_size=1)
        rospy.spin()

    def image_cb(self, msg):
        cv_image = self._bridge.imgmsg_to_cv2(msg, msg.encoding)
        mono = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
        #TODO don't hardcode board dims
        rows = 7
        cols = 10
        (ok, corners) = cv2.findChessboardCorners(mono, (rows, cols), 
            flags = cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE | cv2.CALIB_CB_FAST_CHECK)

        if ok:
            if corners[0, 0, 1] > corners[-1, 0, 1]:
                numpy.flipud(corners)

            # refine detected corners
            # Use a radius of half the minimum distance between corners. This should be large enough to snap to the
            # correct corner, but not so large as to include a wrong corner in the search window.
            dist = lambda p1, p2: math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
            min_distance = float("inf")
            for index in range(len(corners)):
                if (index + 1) % cols:
                    min_distance = min(min_distance, dist(corners[index, 0], corners[index + 1, 0]))
                if index + cols < len(corners):
                    min_distance = min(min_distance, dist(corners[index, 0], corners[index + cols, 0]))

            radius = int(math.ceil(min_distance * 0.5))
            cv2.cornerSubPix(mono, corners, (radius,radius), (-1,-1),
                                        ( cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.1 ))
            
            for index in range(len(corners)):
                cv2.circle(cv_image, (corners[index, 0, 0], corners[index, 0, 1]), 3, (0, 0, 255), 1)
                
        self._img_pub.publish(self._bridge.cv2_to_imgmsg(cv_image))

if __name__ == '__main__':
    rospy.init_node('calib_test', anonymous=True)
    LaserCamCalib()